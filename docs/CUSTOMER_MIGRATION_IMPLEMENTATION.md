# Í≥†Í∞ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Supabase ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Íµ¨ÌòÑ Í∞ÄÏù¥Îìú

> **Ï∞∏Ï°∞ Î¨∏ÏÑú**: CUSTOMER_MIGRATION_TO_SUPABASE.md  
> **Íµ¨ÌòÑ Îã®Í≥Ñ**: PhaseÎ≥Ñ ÏÉÅÏÑ∏ Íµ¨ÌòÑ Í∞ÄÏù¥Îìú  
> **ÏóÖÎç∞Ïù¥Ìä∏**: 2025-05-31  

## üìã Î™©Ï∞®

- [Íµ¨ÌòÑ ÌôòÍ≤Ω ÏÑ§Ï†ï](#Íµ¨ÌòÑ-ÌôòÍ≤Ω-ÏÑ§Ï†ï)
- [Phase 1: Ïù∏ÌîÑÎùº Ï§ÄÎπÑ](#phase-1-Ïù∏ÌîÑÎùº-Ï§ÄÎπÑ)
- [Phase 2: Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò](#phase-2-Îç∞Ïù¥ÌÑ∞-ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò)
- [Phase 3: API Í∞úÎ∞ú](#phase-3-api-Í∞úÎ∞ú)
- [Phase 4: ÏñºÍµ¥ Ïù∏Ïãù ÏãúÏä§ÌÖú](#phase-4-ÏñºÍµ¥-Ïù∏Ïãù-ÏãúÏä§ÌÖú)
- [Phase 5: ÌÜµÌï© ÌÖåÏä§Ìä∏](#phase-5-ÌÜµÌï©-ÌÖåÏä§Ìä∏)
- [Ìä∏Îü¨Î∏îÏäàÌåÖ](#Ìä∏Îü¨Î∏îÏäàÌåÖ)

## üîß Íµ¨ÌòÑ ÌôòÍ≤Ω ÏÑ§Ï†ï

### 1. ÌôòÍ≤Ω Î≥ÄÏàò Ï∂îÍ∞Ä

```env
# .env.localÏóê Ï∂îÍ∞Ä
# Í≥†Í∞ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏÑ§Ï†ï
USE_SUPABASE_CUSTOMER=false  # ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å ÌõÑ trueÎ°ú Î≥ÄÍ≤Ω
CUSTOMER_MIGRATION_MODE=true # ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ëÏóêÎßå true

# Supabase Storage ÏÑ§Ï†ï (Í∏∞Ï°¥ ÏÑ§Ï†ï ÌôïÏû•)
SUPABASE_CUSTOMER_BUCKET=customer-profiles
```

### 2. TypeScript ÌÉÄÏûÖ Ï†ïÏùò

```typescript
// app/lib/types/customer.ts
export interface NotionCustomerData {
  id: string;
  customer_id: string;
  name: string;
  phone?: string;
  gender?: string;
  birth_date?: string;
  estimated_age?: number;
  address?: string;
  special_notes?: string;
  face_embedding?: string; // JSON Î¨∏ÏûêÏó¥
  drive_folder_id?: string;
  is_deleted: boolean;
  consultation_count: number;
  created_at: string;
}

export interface SupabaseCustomerData {
  id?: string;
  customer_id: string;
  notion_id?: string;
  name: string;
  phone?: string;
  gender?: string;
  birth_date?: string;
  estimated_age?: number;
  address?: string;
  special_notes?: string;
  face_embedding?: FaceEmbeddingData;
  face_image_url?: string;
  drive_folder_id?: string;
  storage_folder_path?: string;
  is_deleted?: boolean;
  deleted_at?: string;
  created_at?: string;
  updated_at?: string;
  consultation_count?: number;
  last_consultation_date?: string;
}

export interface FaceEmbeddingData {
  faceDetected: boolean;
  confidence: number;
  embedding: {
    eyeDistanceRatio: number;
    eyeNoseRatio: number;
    noseMouthRatio: number;
    symmetryScore: number;
    contourFeatures: string;
    faceWidth?: number;
    faceHeight?: number;
  };
  demographics: {
    gender: string;
    ageRange: string;
  };
  distinctiveFeatures: string[];
  imageMetadata: {
    quality: number;
    lighting: string;
    angle: string;
  };
  processingInfo: {
    model: string;
    version: string;
    timestamp: string;
  };
}
```

## üèóÔ∏è Phase 1: Ïù∏ÌîÑÎùº Ï§ÄÎπÑ

### 1.1 Supabase Storage ÏÑ§Ï†ï

```typescript
// scripts/setup-customer-storage.ts
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function setupCustomerStorage() {
  console.log('üë• Í≥†Í∞ù ÌîÑÎ°úÌïÑ Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï ÏãúÏûë...');

  try {
    // 1. Í≥†Í∞ù ÌîÑÎ°úÌïÑ Î≤ÑÌÇ∑ ÏÉùÏÑ±
    const { data: bucket, error: bucketError } = await supabase.storage.createBucket(
      'customer-profiles',
      {
        public: true,
        allowedMimeTypes: ['image/jpeg', 'image/png', 'image/webp'],
        fileSizeLimit: 10485760, // 10MB
      }
    );

    if (bucketError && bucketError.message !== 'Bucket already exists') {
      throw bucketError;
    }

    console.log('‚úÖ customer-profiles Î≤ÑÌÇ∑ ÏÉùÏÑ±:', bucket || 'Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®');

    // 2. Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ïÏ±Ö ÏÑ§Ï†ï (ÏàòÎèô ÏÑ§Ï†ï ÌïÑÏöî)
    console.log('‚ÑπÔ∏è Îã§Ïùå Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ïÏ±ÖÏùÑ Supabase DashboardÏóêÏÑú ÏàòÎèôÏúºÎ°ú ÏÑ§Ï†ïÌïòÏÑ∏Ïöî:');
    console.log(`
-- Í≥†Í∞ù ÌîÑÎ°úÌïÑ ÏùΩÍ∏∞ Ï†ïÏ±Ö
CREATE POLICY "Customer profiles read access" ON storage.objects 
FOR SELECT TO public USING (bucket_id = 'customer-profiles');

-- Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©Ïûê ÏóÖÎ°úÎìú Ï†ïÏ±Ö
CREATE POLICY "Authenticated customer upload" ON storage.objects 
FOR INSERT TO authenticated WITH CHECK (bucket_id = 'customer-profiles');

-- Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©Ïûê ÏóÖÎç∞Ïù¥Ìä∏ Ï†ïÏ±Ö
CREATE POLICY "Customer profile update" ON storage.objects 
FOR UPDATE TO authenticated USING (bucket_id = 'customer-profiles');

-- Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©Ïûê ÏÇ≠Ï†ú Ï†ïÏ±Ö
CREATE POLICY "Customer profile delete" ON storage.objects 
FOR DELETE TO authenticated USING (bucket_id = 'customer-profiles');
    `);

    // 3. ÌÖåÏä§Ìä∏ Ìè¥Îçî ÏÉùÏÑ±
    await createTestCustomerFolder();

    console.log('üéâ Í≥†Í∞ù Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï ÏôÑÎ£å');
    return true;

  } catch (error) {
    console.error('üí• Í≥†Í∞ù Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï Ïã§Ìå®:', error);
    throw error;
  }
}

async function createTestCustomerFolder() {
  const testFolderPath = 'test/';
  
  const { error } = await supabase.storage
    .from('customer-profiles')
    .upload(`${testFolderPath}.keep`, new Blob(['test'], { type: 'text/plain' }));

  if (error && !error.message.includes('already exists')) {
    console.warn('ÌÖåÏä§Ìä∏ Ìè¥Îçî ÏÉùÏÑ± Ïã§Ìå®:', error);
  } else {
    console.log('‚úÖ ÌÖåÏä§Ìä∏ Ìè¥Îçî ÏÉùÏÑ± ÏôÑÎ£å');
  }
}

// Ïã§Ìñâ
if (require.main === module) {
  setupCustomerStorage()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}
```

### 1.2 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï†ÅÏö©

```sql
-- database/customer_schema.sql
-- Í≥†Í∞ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÌÖåÏù¥Î∏î ÏÉùÏÑ±

-- 1. customers ÌÖåÏù¥Î∏î ÏÉùÏÑ±
CREATE TABLE IF NOT EXISTS customers (
  -- Í∏∞Î≥∏ ÏãùÎ≥ÑÏûê
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id VARCHAR(10) UNIQUE NOT NULL,
  notion_id VARCHAR(100), -- ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï∂îÏ†ÅÏö©
  
  -- Í∏∞Î≥∏ Ï†ïÎ≥¥
  name VARCHAR(100) NOT NULL,
  phone VARCHAR(20),
  gender VARCHAR(10) CHECK (gender IN ('ÎÇ®ÏÑ±', 'Ïó¨ÏÑ±', 'Í∏∞ÌÉÄ', 'Î∂àÎ™Ö')),
  birth_date DATE,
  estimated_age INTEGER,
  address TEXT,
  special_notes TEXT,
  
  -- ÏñºÍµ¥ Ïù∏Ïãù Îç∞Ïù¥ÌÑ∞
  face_embedding JSONB,
  face_image_url TEXT,
  face_samples_count INTEGER DEFAULT 0,
  face_last_updated TIMESTAMP WITH TIME ZONE,
  
  -- Ìè¥Îçî Í¥ÄÎ¶¨
  drive_folder_id VARCHAR(100), -- Í∏∞Ï°¥ Google Drive ID (Ìò∏ÌôòÏö©)
  storage_folder_path VARCHAR(200), -- Supabase Storage Í≤ΩÎ°ú
  
  -- ÏÉÅÌÉú Í¥ÄÎ¶¨
  is_deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMP WITH TIME ZONE,
  deleted_by VARCHAR(100),
  
  -- ÌÜµÍ≥Ñ Ï†ïÎ≥¥
  consultation_count INTEGER DEFAULT 0,
  last_consultation_date DATE,
  
  -- Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  -- Ï†úÏïΩ Ï°∞Í±¥
  CONSTRAINT customers_customer_id_format 
    CHECK (customer_id ~ '^[0-9]{5}$'),
  CONSTRAINT customers_phone_format 
    CHECK (phone IS NULL OR length(trim(phone)) > 0),
  CONSTRAINT customers_age_range 
    CHECK (estimated_age IS NULL OR (estimated_age >= 0 AND estimated_age <= 150)),
  CONSTRAINT customers_name_not_empty 
    CHECK (length(trim(name)) > 0)
);

-- 2. Í∏∞Î≥∏ Ïù∏Îç±Ïä§ ÏÉùÏÑ±
CREATE UNIQUE INDEX IF NOT EXISTS idx_customers_customer_id 
  ON customers(customer_id);
CREATE INDEX IF NOT EXISTS idx_customers_name 
  ON customers(name);
CREATE INDEX IF NOT EXISTS idx_customers_phone 
  ON customers(phone) WHERE phone IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_customers_is_deleted 
  ON customers(is_deleted);
CREATE INDEX IF NOT EXISTS idx_customers_created_at 
  ON customers(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_customers_notion_id 
  ON customers(notion_id) WHERE notion_id IS NOT NULL;

-- 3. Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ Ïù∏Îç±Ïä§
CREATE INDEX IF NOT EXISTS idx_customers_name_fts 
  ON customers USING gin(to_tsvector('korean', name));
CREATE INDEX IF NOT EXISTS idx_customers_address_fts 
  ON customers USING gin(to_tsvector('korean', coalesce(address, '')));
CREATE INDEX IF NOT EXISTS idx_customers_notes_fts 
  ON customers USING gin(to_tsvector('korean', coalesce(special_notes, '')));

-- 4. ÏñºÍµ¥ ÏûÑÎ≤†Îî© Í≤ÄÏÉâ Ïù∏Îç±Ïä§
CREATE INDEX IF NOT EXISTS idx_customers_face_embedding 
  ON customers USING gin(face_embedding) 
  WHERE face_embedding IS NOT NULL;

-- 5. ÏóÖÎç∞Ïù¥Ìä∏ Ìä∏Î¶¨Í±∞
CREATE OR REPLACE FUNCTION update_customers_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_customers_updated_at ON customers;
CREATE TRIGGER update_customers_updated_at 
  BEFORE UPDATE ON customers 
  FOR EACH ROW 
  EXECUTE FUNCTION update_customers_updated_at();

-- 6. RLS Ï†ïÏ±Ö
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public read active customers" ON customers;
CREATE POLICY "Public read active customers" ON customers 
  FOR SELECT TO public USING (is_deleted = false);

DROP POLICY IF EXISTS "Authenticated full access" ON customers;
CREATE POLICY "Authenticated full access" ON customers 
  FOR ALL TO authenticated USING (true);

-- 7. Í≥†Í∞ù Î≤àÌò∏ ÏûêÎèô ÏÉùÏÑ± Ìï®Ïàò
CREATE OR REPLACE FUNCTION generate_next_customer_id()
RETURNS VARCHAR(10) AS $$
DECLARE
  next_number INTEGER;
  max_id VARCHAR(10);
BEGIN
  -- ÌòÑÏû¨ ÏµúÎåÄ Í≥†Í∞ù Î≤àÌò∏ Ï°∞Ìöå
  SELECT customer_id INTO max_id
  FROM customers 
  WHERE customer_id ~ '^[0-9]{5}$'
  ORDER BY CAST(customer_id AS INTEGER) DESC
  LIMIT 1;
  
  IF max_id IS NULL THEN
    next_number := 1;
  ELSE
    next_number := CAST(max_id AS INTEGER) + 1;
  END IF;
  
  RETURN lpad(next_number::TEXT, 5, '0');
END;
$$ LANGUAGE plpgsql;

-- 8. Í≥†Í∞ù ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
CREATE OR REPLACE FUNCTION update_customer_consultation_stats(customer_uuid UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE customers 
  SET 
    consultation_count = (
      SELECT COUNT(*) 
      FROM consultations 
      WHERE customer_id = customer_uuid
    ),
    last_consultation_date = (
      SELECT MAX(consult_date) 
      FROM consultations 
      WHERE customer_id = customer_uuid
    ),
    updated_at = now()
  WHERE id = customer_uuid;
END;
$$ LANGUAGE plpgsql;

-- 9. Í≥†Í∞ù Í≤ÄÏÉâ Ìï®Ïàò
CREATE OR REPLACE FUNCTION search_customers(
  search_term TEXT DEFAULT NULL,
  search_phone TEXT DEFAULT NULL,
  search_gender VARCHAR(10) DEFAULT NULL,
  include_deleted BOOLEAN DEFAULT false,
  page_size INTEGER DEFAULT 20,
  page_offset INTEGER DEFAULT 0
)
RETURNS TABLE(
  id UUID,
  customer_id VARCHAR(10),
  name VARCHAR(100),
  phone VARCHAR(20),
  gender VARCHAR(10),
  estimated_age INTEGER,
  consultation_count INTEGER,
  last_consultation_date DATE,
  created_at TIMESTAMP WITH TIME ZONE,
  has_face_data BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id, c.customer_id, c.name, c.phone, c.gender, 
    c.estimated_age, c.consultation_count, 
    c.last_consultation_date, c.created_at,
    (c.face_embedding IS NOT NULL) as has_face_data
  FROM customers c
  WHERE 
    (include_deleted = true OR c.is_deleted = false)
    AND (search_term IS NULL OR (
      c.name ILIKE '%' || search_term || '%' OR
      c.address ILIKE '%' || search_term || '%' OR
      c.special_notes ILIKE '%' || search_term || '%' OR
      c.customer_id ILIKE '%' || search_term || '%'
    ))
    AND (search_phone IS NULL OR c.phone ILIKE '%' || search_phone || '%')
    AND (search_gender IS NULL OR c.gender = search_gender)
  ORDER BY 
    CASE WHEN search_term IS NOT NULL AND c.name ILIKE search_term || '%' THEN 1 ELSE 2 END,
    c.consultation_count DESC,
    c.name
  LIMIT page_size OFFSET page_offset;
END;
$$ LANGUAGE plpgsql;

-- ÏôÑÎ£å Î©îÏãúÏßÄ
SELECT 'customer_schema.sql Ï†ÅÏö© ÏôÑÎ£å' AS message;
```

## üì¶ Phase 2: Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò

### 2.1 Notion Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú

```typescript
// scripts/extract-notion-customers.ts
import { Client } from '@notionhq/client';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { NotionCustomerData } from '../app/lib/types/customer';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const notion = new Client({ auth: process.env.NOTION_API_KEY });

export async function extractAllNotionCustomers(): Promise<NotionCustomerData[]> {
  console.log('üë• Notion Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏãúÏûë...');

  try {
    const customers: NotionCustomerData[] = [];
    let hasMore = true;
    let nextCursor: string | undefined;

    while (hasMore) {
      console.log(`ÌéòÏù¥ÏßÄ Ï°∞Ìöå Ï§ë... (Ïª§ÏÑú: ${nextCursor || 'ÏãúÏûë'})`);

      const response = await notion.databases.query({
        database_id: process.env.NOTION_CUSTOMER_DB_ID!,
        start_cursor: nextCursor,
        page_size: 100,
        sorts: [
          {
            property: 'id',
            direction: 'ascending'
          }
        ]
      });

      for (const page of response.results) {
        try {
          const customer = await parseNotionCustomer(page as any);
          if (customer) {
            customers.push(customer);
          }
        } catch (error) {
          console.error(`Í≥†Í∞ù ÌéòÏù¥ÏßÄ ÌååÏã± Ïã§Ìå® (${page.id}):`, error);
        }
      }

      hasMore = response.has_more;
      nextCursor = response.next_cursor || undefined;

      console.log(`ÌòÑÏû¨ÍπåÏßÄ Ï∂îÏ∂úÎêú Í≥†Í∞ù: ${customers.length}Í∞ú`);
    }

    // Í≤∞Í≥º Ï†ÄÏû•
    const migrationDir = join(process.cwd(), 'migration_data');
    if (!existsSync(migrationDir)) {
      mkdirSync(migrationDir, { recursive: true });
    }

    const outputPath = join(migrationDir, 'notion_customers.json');
    writeFileSync(outputPath, JSON.stringify(customers, null, 2));

    console.log(`üéâ Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú ÏôÑÎ£å: Ï¥ù ${customers.length}Í∞úÏùò Í≥†Í∞ù`);
    console.log(`üíæ Ï†ÄÏû• ÏúÑÏπò: ${outputPath}`);

    // ÌÜµÍ≥Ñ Ï∂úÎ†•
    printCustomerStatistics(customers);

    return customers;

  } catch (error) {
    console.error('üí• Notion Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®:', error);
    throw error;
  }
}

async function parseNotionCustomer(page: any): Promise<NotionCustomerData | null> {
  try {
    const properties = page.properties;

    // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    const customerId = getNotionPropertyValue(properties.id, 'title');
    const name = getNotionPropertyValue(properties.Í≥†Í∞ùÎ™Ö, 'rich_text');

    if (!customerId || !name) {
      console.warn(`ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ, Í±¥ÎÑàÎõ∞Í∏∞: ${customerId || page.id}`);
      return null;
    }

    const customer: NotionCustomerData = {
      id: page.id,
      customer_id: customerId,
      name: name,
      phone: getNotionPropertyValue(properties.Ï†ÑÌôîÎ≤àÌò∏, 'phone_number'),
      gender: getNotionPropertyValue(properties.ÏÑ±Î≥Ñ, 'select'),
      birth_date: getNotionPropertyValue(properties.ÏÉùÎÖÑÏõîÏùº, 'date'),
      estimated_age: getNotionPropertyValue(properties.Ï∂îÏ†ïÎÇòÏù¥, 'number'),
      address: getNotionPropertyValue(properties.Ï£ºÏÜå, 'rich_text'),
      special_notes: getNotionPropertyValue(properties.ÌäπÏù¥ÏÇ¨Ìï≠, 'rich_text'),
      face_embedding: getNotionPropertyValue(properties.ÏñºÍµ¥_ÏûÑÎ≤†Îî©, 'rich_text'),
      drive_folder_id: getNotionPropertyValue(properties.customerFolderId, 'rich_text'),
      is_deleted: getNotionPropertyValue(properties.ÏÇ≠Ï†úÎê®, 'checkbox') || false,
      consultation_count: getNotionPropertyValue(properties.ÏÉÅÎã¥Ïàò, 'formula') || 0,
      created_at: page.created_time
    };

    return customer;

  } catch (error) {
    console.error(`Í≥†Í∞ù ÌååÏã± Ïò§Î•ò (${page.id}):`, error);
    return null;
  }
}

function getNotionPropertyValue(property: any, type: string): any {
  if (!property) return null;

  switch (type) {
    case 'title':
      return property.title?.[0]?.text?.content || null;
    case 'rich_text':
      return property.rich_text?.[0]?.text?.content || null;
    case 'phone_number':
      return property.phone_number || null;
    case 'select':
      return property.select?.name || null;
    case 'date':
      return property.date?.start || null;
    case 'number':
      return property.number || null;
    case 'checkbox':
      return property.checkbox || false;
    case 'formula':
      return property.formula?.number || 0;
    default:
      return null;
  }
}

function printCustomerStatistics(customers: NotionCustomerData[]) {
  console.log('\nüìä Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ:');
  
  const activeCustomers = customers.filter(c => !c.is_deleted);
  const deletedCustomers = customers.filter(c => c.is_deleted);
  
  console.log(`- Ï†ÑÏ≤¥ Í≥†Í∞ù: ${customers.length}Í∞ú`);
  console.log(`- ÌôúÏÑ± Í≥†Í∞ù: ${activeCustomers.length}Í∞ú`);
  console.log(`- ÏÇ≠Ï†úÎêú Í≥†Í∞ù: ${deletedCustomers.length}Í∞ú`);
  
  // ÏÑ±Î≥Ñ ÌÜµÍ≥Ñ
  const genderStats = customers.reduce((acc, customer) => {
    const gender = customer.gender || 'ÎØ∏ÏßÄÏ†ï';
    acc[gender] = (acc[gender] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  console.log('- ÏÑ±Î≥Ñ Î∂ÑÌè¨:');
  Object.entries(genderStats).forEach(([gender, count]) => {
    console.log(`  ${gender}: ${count}Î™Ö`);
  });
  
  // ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ
  const withFaceData = customers.filter(c => c.face_embedding && c.face_embedding.length > 0);
  console.log(`- ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞ Î≥¥Ïú†: ${withFaceData.length}Í∞ú (${Math.round(withFaceData.length / customers.length * 100)}%)`);
  
  // ÏÉÅÎã¥ ÌÜµÍ≥Ñ
  const totalConsultations = customers.reduce((sum, customer) => sum + customer.consultation_count, 0);
  const avgConsultations = totalConsultations / customers.length;
  console.log(`- Ï¥ù ÏÉÅÎã¥ Ïàò: ${totalConsultations}Í∞ú`);
  console.log(`- ÌèâÍ∑† ÏÉÅÎã¥ Ïàò: ${avgConsultations.toFixed(1)}Í∞ú/Í≥†Í∞ù`);
}

// Ïã§Ìñâ
if (require.main === module) {
  extractAllNotionCustomers()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}
```

### 2.2 Supabase Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ

```typescript
// scripts/insert-customer-data.ts
import { createClient } from '@supabase/supabase-js';
import { readFileSync } from 'fs';
import { join } from 'path';
import { NotionCustomerData, SupabaseCustomerData } from '../app/lib/types/customer';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function insertCustomerData(): Promise<void> {
  console.log('üë• Supabase Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏãúÏûë...');

  try {
    // Ï∂îÏ∂úÎêú Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    const customersPath = join(process.cwd(), 'migration_data', 'notion_customers.json');
    const notionCustomers: NotionCustomerData[] = JSON.parse(readFileSync(customersPath, 'utf-8'));

    console.log(`üì• Î°úÎìúÎêú Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞: ${notionCustomers.length}Í∞ú`);

    // Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
    const transformedCustomers = notionCustomers.map(transformNotionCustomer);

    // Î∞∞Ïπò Îã®ÏúÑÎ°ú ÏÇΩÏûÖ
    const batchSize = 25;
    const batches = chunkArray(transformedCustomers, batchSize);
    
    let insertedCount = 0;
    let errorCount = 0;

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      console.log(`Î∞∞Ïπò ${i + 1}/${batches.length} Ï≤òÎ¶¨ Ï§ë... (${batch.length}Í∞ú)`);

      try {
        // Í∞Å Í≥†Í∞ùÏùò Ïä§ÌÜ†Î¶¨ÏßÄ Ìè¥Îçî ÏÉùÏÑ±
        for (const customer of batch) {
          await createCustomerStorageFolder(customer.customer_id);
        }

        // Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
        const { data, error } = await supabase
          .from('customers')
          .insert(batch)
          .select();

        if (error) throw error;

        insertedCount += data.length;
        console.log(`‚úÖ Î∞∞Ïπò ${i + 1} ÏôÑÎ£å: ${data.length}Í∞ú ÏÇΩÏûÖ`);

      } catch (error: any) {
        console.error(`Î∞∞Ïπò ${i + 1} ÏÇΩÏûÖ Ïã§Ìå®:`, error.message);
        errorCount += batch.length;
      }

      // API Î∂ÄÌïò Î∞©ÏßÄ
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    console.log(`üéâ Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏôÑÎ£å: ÏÑ±Í≥µ ${insertedCount}Í∞ú, Ïã§Ìå® ${errorCount}Í∞ú`);

    // Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
    await validateInsertedData();

  } catch (error) {
    console.error('üí• Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïã§Ìå®:', error);
    throw error;
  }
}

function transformNotionCustomer(notionCustomer: NotionCustomerData): SupabaseCustomerData {
  // ÏñºÍµ¥ ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞ ÌååÏã±
  let faceEmbedding = null;
  if (notionCustomer.face_embedding && notionCustomer.face_embedding.length > 0) {
    try {
      const oldEmbedding = JSON.parse(notionCustomer.face_embedding);
      faceEmbedding = convertFaceEmbedding(oldEmbedding);
    } catch (error) {
      console.warn(`ÏñºÍµ¥ ÏûÑÎ≤†Îî© ÌååÏã± Ïã§Ìå® (${notionCustomer.customer_id}):`, error);
    }
  }

  return {
    customer_id: notionCustomer.customer_id,
    notion_id: notionCustomer.id,
    name: notionCustomer.name,
    phone: notionCustomer.phone,
    gender: notionCustomer.gender,
    birth_date: notionCustomer.birth_date,
    estimated_age: notionCustomer.estimated_age,
    address: notionCustomer.address,
    special_notes: notionCustomer.special_notes,
    face_embedding: faceEmbedding,
    drive_folder_id: notionCustomer.drive_folder_id,
    storage_folder_path: `${notionCustomer.customer_id}/`,
    is_deleted: notionCustomer.is_deleted,
    consultation_count: notionCustomer.consultation_count,
    created_at: notionCustomer.created_at
  };
}

function convertFaceEmbedding(oldEmbedding: any): any {
  // Í∏∞Ï°¥ Notion ÌòïÏãùÏùÑ ÏÉàÎ°úÏö¥ Supabase ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
  return {
    faceDetected: oldEmbedding.faceDetected || false,
    confidence: calculateConfidence(oldEmbedding),
    embedding: {
      eyeDistanceRatio: oldEmbedding.embedding?.eyeDistanceRatio || 0.45,
      eyeNoseRatio: oldEmbedding.embedding?.eyeNoseRatio || 0.35,
      noseMouthRatio: oldEmbedding.embedding?.noseMouthRatio || 0.25,
      symmetryScore: oldEmbedding.embedding?.symmetryScore || 0.8,
      contourFeatures: oldEmbedding.embedding?.contourFeatures || 'ÌÉÄÏõêÌòï',
      faceWidth: oldEmbedding.embedding?.faceWidth || 1.0,
      faceHeight: oldEmbedding.embedding?.faceHeight || 1.0
    },
    demographics: {
      gender: oldEmbedding.gender || 'Î∂àÎ™Ö',
      ageRange: calculateAgeRange(oldEmbedding.age || 30)
    },
    distinctiveFeatures: oldEmbedding.distinctiveFeatures || [],
    imageMetadata: {
      quality: oldEmbedding.imageQualityScore || 70,
      lighting: 'Î≥¥ÌÜµ',
      angle: 'Ï†ïÎ©¥'
    },
    processingInfo: {
      model: 'gemini-1.5-flash',
      version: '2024',
      timestamp: new Date().toISOString()
    }
  };
}

function calculateConfidence(oldEmbedding: any): number {
  const qualityScore = oldEmbedding.imageQualityScore || 70;
  const faceDetected = oldEmbedding.faceDetected || false;
  
  if (!faceDetected) return 0.0;
  return Math.min(1.0, qualityScore / 100);
}

function calculateAgeRange(age: number): string {
  if (age < 20) return '10ÎåÄ';
  if (age < 30) return '20ÎåÄ';
  if (age < 40) return '30ÎåÄ';
  if (age < 50) return '40ÎåÄ';
  if (age < 60) return '50ÎåÄ';
  if (age < 70) return '60ÎåÄ';
  return '70ÎåÄ Ïù¥ÏÉÅ';
}

async function createCustomerStorageFolder(customerId: string): Promise<void> {
  try {
    const folderPath = `${customerId}/`;
    
    const { error } = await supabase.storage
      .from('customer-profiles')
      .upload(`${folderPath}.keep`, new Blob([''], { type: 'text/plain' }), {
        upsert: true
      });

    if (error && !error.message.includes('already exists')) {
      console.warn(`Ìè¥Îçî ÏÉùÏÑ± Ïã§Ìå® (${customerId}):`, error.message);
    }

  } catch (error) {
    console.warn(`Ìè¥Îçî ÏÉùÏÑ± Ïò§Î•ò (${customerId}):`, error);
  }
}

async function validateInsertedData(): Promise<void> {
  console.log('üîç ÏÇΩÏûÖÎêú Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Ï§ë...');

  try {
    const { data: stats, error: statsError } = await supabase
      .from('customers')
      .select('id, is_deleted', { count: 'exact' });

    if (!statsError && stats) {
      const activeCount = stats.filter(c => !c.is_deleted).length;
      const deletedCount = stats.filter(c => c.is_deleted).length;
      
      console.log(`üìä Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ:`);
      console.log(`- Ï¥ù Í≥†Í∞ù Ïàò: ${stats.length}Í∞ú`);
      console.log(`- ÌôúÏÑ± Í≥†Í∞ù: ${activeCount}Í∞ú`);
      console.log(`- ÏÇ≠Ï†úÎêú Í≥†Í∞ù: ${deletedCount}Í∞ú`);
    }

  } catch (error) {
    console.error('Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Ï§ë Ïò§Î•ò:', error);
  }
}

function chunkArray<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

// Ïã§Ìñâ
if (require.main === module) {
  insertCustomerData()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}
```

## üîß Phase 3: API Í∞úÎ∞ú

### 3.1 ÏÉàÎ°úÏö¥ Supabase Í∏∞Î∞ò Í≥†Í∞ù API

```typescript
// app/api/customer-v2/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Í≥†Í∞ù Í≤ÄÏÉâ Î∞è Î™©Î°ù Ï°∞Ìöå
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const search = searchParams.get('search') || searchParams.get('name');
  const phone = searchParams.get('phone');
  const gender = searchParams.get('gender');
  const customerId = searchParams.get('id');
  const includeDeleted = searchParams.get('includeDeleted') === 'true';
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '20');

  // ÌäπÏ†ï Í≥†Í∞ù IDÎ°ú Ï°∞Ìöå
  if (customerId) {
    return getCustomerById(customerId);
  }

  try {
    const { data, error } = await supabase
      .rpc('search_customers', {
        search_term: search,
        search_phone: phone,
        search_gender: gender,
        include_deleted: includeDeleted,
        page_size: limit,
        page_offset: (page - 1) * limit
      });

    if (error) throw error;

    // Í∏∞Ï°¥ Notion API ÏùëÎãµ ÌòïÏãùÍ≥º Ìò∏Ìôò
    const customers = data.map(customer => ({
      id: customer.id,
      properties: {
        id: {
          title: [{ text: { content: customer.customer_id } }]
        },
        Í≥†Í∞ùÎ™Ö: {
          rich_text: [{ text: { content: customer.name } }]
        },
        Ï†ÑÌôîÎ≤àÌò∏: {
          phone_number: customer.phone
        },
        ÏÑ±Î≥Ñ: {
          select: customer.gender ? { name: customer.gender } : null
        },
        Ï∂îÏ†ïÎÇòÏù¥: {
          number: customer.estimated_age
        },
        ÏÉÅÎã¥Ïàò: {
          formula: { number: customer.consultation_count }
        },
        has_face_data: customer.has_face_data
      }
    }));

    return NextResponse.json({
      success: true,
      customers,
      totalCount: data.length
    });

  } catch (error) {
    console.error('Í≥†Í∞ù Ï°∞Ìöå Ïò§Î•ò:', error);
    return NextResponse.json(
      { error: 'Í≥†Í∞ù Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
      { status: 500 }
    );
  }
}

async function getCustomerById(customerId: string) {
  try {
    let query = supabase
      .from('customers')
      .select('*')
      .single();

    // UUID ÌòïÏãùÏù∏ÏßÄ ÌôïÏù∏
    if (customerId.includes('-')) {
      query = query.eq('id', customerId);
    } else {
      query = query.eq('customer_id', customerId);
    }

    const { data: customer, error } = await query;

    if (error) throw error;

    if (!customer) {
      return NextResponse.json(
        { error: 'Í≥†Í∞ùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' },
        { status: 404 }
      );
    }

    // Í∏∞Ï°¥ API ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    const formattedCustomer = {
      id: customer.id,
      properties: {
        id: {
          title: [{ text: { content: customer.customer_id } }]
        },
        Í≥†Í∞ùÎ™Ö: {
          rich_text: [{ text: { content: customer.name } }]
        },
        Ï†ÑÌôîÎ≤àÌò∏: {
          phone_number: customer.phone
        },
        ÏÑ±Î≥Ñ: {
          select: customer.gender ? { name: customer.gender } : null
        },
        ÏÉùÎÖÑÏõîÏùº: {
          date: customer.birth_date ? { start: customer.birth_date } : null
        },
        Ï∂îÏ†ïÎÇòÏù¥: {
          number: customer.estimated_age
        },
        Ï£ºÏÜå: {
          rich_text: customer.address ? [{ text: { content: customer.address } }] : []
        },
        ÌäπÏù¥ÏÇ¨Ìï≠: {
          rich_text: customer.special_notes ? [{ text: { content: customer.special_notes } }] : []
        },
        ÏñºÍµ¥_ÏûÑÎ≤†Îî©: {
          rich_text: customer.face_embedding ? [{ text: { content: JSON.stringify(customer.face_embedding) } }] : []
        },
        ÏÉÅÎã¥Ïàò: {
          formula: { number: customer.consultation_count }
        },
        ÏÇ≠Ï†úÎê®: {
          checkbox: customer.is_deleted
        }
      },
      created_time: customer.created_at,
      last_edited_time: customer.updated_at
    };

    return NextResponse.json({
      success: true,
      customers: [formattedCustomer]
    });

  } catch (error) {
    console.error('ÌäπÏ†ï Í≥†Í∞ù Ï°∞Ìöå Ïò§Î•ò:', error);
    return NextResponse.json(
      { error: 'Í≥†Í∞ù Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
      { status: 500 }
    );
  }
}

// Í≥†Í∞ù Îì±Î°ù
export async function POST(request: Request) {
  try {
    const data = await request.json();

    if (!data.name) {
      return NextResponse.json(
        { error: 'Ïù¥Î¶ÑÏùÄ ÌïÑÏàò ÏûÖÎ†• Ìï≠Î™©ÏûÖÎãàÎã§.' },
        { status: 400 }
      );
    }

    // Îã§Ïùå Í≥†Í∞ù ID ÏÉùÏÑ±
    const { data: nextId, error: idError } = await supabase
      .rpc('generate_next_customer_id');

    if (idError) throw idError;

    // ÏñºÍµ¥ ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
    let faceEmbedding = null;
    if (data.faceEmbedding) {
      if (typeof data.faceEmbedding === 'string') {
        try {
          faceEmbedding = JSON.parse(data.faceEmbedding);
        } catch (error) {
          console.warn('ÏñºÍµ¥ ÏûÑÎ≤†Îî© ÌååÏã± Ïã§Ìå®:', error);
        }
      } else {
        faceEmbedding = data.faceEmbedding;
      }
    }

    // Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    const customerData = {
      customer_id: nextId,
      name: data.name,
      phone: data.phone,
      gender: data.gender,
      birth_date: data.birth,
      estimated_age: data.estimatedAge ? parseInt(data.estimatedAge) : null,
      address: data.address,
      special_notes: data.specialNote,
      face_embedding: faceEmbedding,
      storage_folder_path: `${nextId}/`
    };

    // Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
    const { data: customer, error } = await supabase
      .from('customers')
      .insert(customerData)
      .select()
      .single();

    if (error) throw error;

    // ÌîÑÎ°úÌïÑ Ìè¥Îçî ÏÉùÏÑ±
    await createCustomerStorageFolder(customer.customer_id);

    // Í∏∞Ï°¥ API ÏùëÎãµ ÌòïÏãù Ïú†ÏßÄ
    return NextResponse.json({
      success: true,
      customer: {
        id: customer.id,
        customId: customer.customer_id,
        name: customer.name
      }
    });

  } catch (error: any) {
    console.error('Í≥†Í∞ù Îì±Î°ù Ïò§Î•ò:', error);
    return NextResponse.json(
      { error: `Í≥†Í∞ù Îì±Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}` },
      { status: 500 }
    );
  }
}

async function createCustomerStorageFolder(customerId: string): Promise<void> {
  try {
    const folderPath = `${customerId}/`;
    
    const { error } = await supabase.storage
      .from('customer-profiles')
      .upload(`${folderPath}.keep`, new Blob([''], { type: 'text/plain' }), {
        upsert: true
      });

    if (error && !error.message.includes('already exists')) {
      console.warn(`Ìè¥Îçî ÏÉùÏÑ± Ïã§Ìå® (${customerId}):`, error.message);
    }

  } catch (error) {
    console.warn(`Ìè¥Îçî ÏÉùÏÑ± Ïò§Î•ò (${customerId}):`, error);
  }
}
```

### 3.2 Í∏∞Ï°¥ API Ìò∏ÌôòÏÑ± Ïú†ÏßÄ

```typescript
// app/api/customer/route.ts (Í∏∞Ï°¥ API ÏàòÏ†ï)
import { NextResponse } from 'next/server';

// ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î™®ÎìúÏóê Îî∞Î•∏ ÎùºÏö∞ÌåÖ
const USE_SUPABASE = process.env.USE_SUPABASE_CUSTOMER === 'true';

export async function GET(request: Request) {
  if (USE_SUPABASE) {
    // ÏÉàÎ°úÏö¥ Supabase APIÎ°ú ÎùºÏö∞ÌåÖ
    const { searchParams } = new URL(request.url);
    const newUrl = new URL('/api/customer-v2', request.url);
    newUrl.search = searchParams.toString();
    
    return fetch(newUrl.toString(), {
      method: 'GET',
      headers: request.headers
    });
  } else {
    // Í∏∞Ï°¥ Notion API Ïú†ÏßÄ
    return getCustomersFromNotion(request);
  }
}

export async function POST(request: Request) {
  if (USE_SUPABASE) {
    // ÏÉàÎ°úÏö¥ Supabase APIÎ°ú ÎùºÏö∞ÌåÖ
    const body = await request.json();
    
    return fetch(new URL('/api/customer-v2', request.url).toString(), {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });
  } else {
    // Í∏∞Ï°¥ Notion API Ïú†ÏßÄ
    return postCustomerToNotion(request);
  }
}

// Í∏∞Ï°¥ Notion API Ìï®ÏàòÎì§ (Î∞±ÏóÖÏö©)
async function getCustomersFromNotion(request: Request) {
  // Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ...
}

async function postCustomerToNotion(request: Request) {
  // Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ...
}
```

## üé≠ Phase 4: ÏñºÍµ¥ Ïù∏Ïãù ÏãúÏä§ÌÖú

### 4.1 Ìñ•ÏÉÅÎêú ÏñºÍµ¥ Ïù∏Ïãù API

```typescript
// app/api/face-recognition-v2/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const imageFile = formData.get('image') as File;
    const customerId = formData.get('customerId') as string;
    const updateCustomer = formData.get('updateCustomer') === 'true';

    if (!imageFile) {
      return NextResponse.json(
        { error: 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.' },
        { status: 400 }
      );
    }

    // 1. ÏñºÍµ¥ Î∂ÑÏÑù (Í∏∞Ï°¥ Gemini API ÏÇ¨Ïö©)
    const faceAnalysis = await analyzeFaceWithGemini(imageFile);

    // 2. Í∏∞Ï°¥ Í≥†Í∞ùÍ≥º Îß§Ïπ≠ (customerIdÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞)
    let matchedCustomers = [];
    if (!customerId && faceAnalysis.faceDetected) {
      matchedCustomers = await findSimilarCustomers(faceAnalysis);
    }

    // 3. Í≥†Í∞ù Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Î∞è Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    let imageUrl = null;
    if (customerId && updateCustomer) {
      imageUrl = await saveCustomerFaceImage(customerId, imageFile);
      await updateCustomerFaceData(customerId, faceAnalysis, imageUrl);
    }

    return NextResponse.json({
      success: true,
      data: {
        faceAnalysis,
        matchedCustomers,
        imageUrl
      }
    });

  } catch (error) {
    console.error('ÏñºÍµ¥ Ïù∏Ïãù Ï≤òÎ¶¨ Ïò§Î•ò:', error);
    return NextResponse.json(
      { error: 'ÏñºÍµ¥ Ïù∏Ïãù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' },
      { status: 500 }
    );
  }
}

async function findSimilarCustomers(faceAnalysis: any) {
  try {
    const { data, error } = await supabase
      .rpc('find_similar_faces', {
        target_embedding: faceAnalysis.embedding,
        similarity_threshold: 0.7,
        max_results: 5
      });

    if (error) throw error;
    return data || [];

  } catch (error) {
    console.error('Ïú†ÏÇ¨ Í≥†Í∞ù Í≤ÄÏÉâ Ïò§Î•ò:', error);
    return [];
  }
}

async function saveCustomerFaceImage(customerId: string, imageFile: File): Promise<string> {
  try {
    const fileName = `profile_${Date.now()}.jpg`;
    const filePath = `${customerId}/${fileName}`;

    const { data, error } = await supabase.storage
      .from('customer-profiles')
      .upload(filePath, imageFile, {
        upsert: true
      });

    if (error) throw error;

    const { data: publicUrl } = supabase.storage
      .from('customer-profiles')
      .getPublicUrl(filePath);

    return publicUrl.publicUrl;

  } catch (error) {
    console.error('Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ïò§Î•ò:', error);
    throw error;
  }
}

async function updateCustomerFaceData(
  customerId: string, 
  faceAnalysis: any, 
  imageUrl: string
): Promise<void> {
  try {
    const { error } = await supabase
      .from('customers')
      .update({
        face_embedding: faceAnalysis,
        face_image_url: imageUrl,
        face_last_updated: new Date().toISOString()
      })
      .eq('customer_id', customerId);

    if (error) throw error;

  } catch (error) {
    console.error('Í≥†Í∞ù ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error);
    throw error;
  }
}

async function analyzeFaceWithGemini(imageFile: File): Promise<any> {
  // Í∏∞Ï°¥ Gemini Î∂ÑÏÑù Î°úÏßÅ Ïû¨ÏÇ¨Ïö©
  const formData = new FormData();
  formData.append('image', imageFile);

  const response = await fetch('/api/face-embedding', {
    method: 'POST',
    body: formData
  });

  const result = await response.json();
  return result.data;
}
```

## üß™ Phase 5: ÌÜµÌï© ÌÖåÏä§Ìä∏

### 5.1 ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ïä§ÌÅ¨Î¶ΩÌä∏

```typescript
// scripts/test-customer-migration.ts
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function testCustomerMigration(): Promise<void> {
  console.log('üß™ Í≥†Í∞ù ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌÖåÏä§Ìä∏ ÏãúÏûë...');

  try {
    // 1. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
    await testDatabaseConnection();

    // 2. Ïä§ÌÇ§Îßà Í≤ÄÏ¶ù
    await testSchema();

    // 3. Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨
    await testDataIntegrity();

    // 4. API ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌÖåÏä§Ìä∏
    await testAPIEndpoints();

    // 5. ÏñºÍµ¥ Ïù∏Ïãù Í∏∞Îä• ÌÖåÏä§Ìä∏
    await testFaceRecognition();

    // 6. ÏÑ±Îä• ÌÖåÏä§Ìä∏
    await testPerformance();

    console.log('‚úÖ Î™®Îì† ÌÖåÏä§Ìä∏ ÌÜµÍ≥º');

  } catch (error) {
    console.error('‚ùå ÌÖåÏä§Ìä∏ Ïã§Ìå®:', error);
    throw error;
  }
}

async function testDatabaseConnection(): Promise<void> {
  console.log('üîå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏...');

  const { data, error } = await supabase
    .from('customers')
    .select('count', { count: 'exact' })
    .limit(1);

  if (error) throw new Error(`Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®: ${error.message}`);

  console.log(`üìä Í≥†Í∞ù ÌÖåÏù¥Î∏î Î†àÏΩîÎìú Ïàò: ${data.length}`);
}

async function testSchema(): Promise<void> {
  console.log('üìã Ïä§ÌÇ§Îßà Í≤ÄÏ¶ù...');

  // ÌïÑÏàò ÌÖåÏù¥Î∏î Ï°¥Ïû¨ ÌôïÏù∏
  const { data: tables, error } = await supabase
    .from('information_schema.tables')
    .select('table_name')
    .eq('table_schema', 'public')
    .eq('table_name', 'customers');

  if (error || !tables || tables.length === 0) {
    throw new Error('customers ÌÖåÏù¥Î∏îÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
  }

  // ÌïÑÏàò Ìï®Ïàò ÌÖåÏä§Ìä∏
  const { data: nextId, error: funcError } = await supabase
    .rpc('generate_next_customer_id');

  if (funcError) {
    throw new Error(`Ìï®Ïàò ÌÖåÏä§Ìä∏ Ïã§Ìå®: ${funcError.message}`);
  }

  console.log(`‚úÖ Ïä§ÌÇ§Îßà Í≤ÄÏ¶ù ÌÜµÍ≥º, Îã§Ïùå Í≥†Í∞ù ID: ${nextId}`);
}

async function testDataIntegrity(): Promise<void> {
  console.log('üîç Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨...');

  // Í∏∞Î≥∏ ÌÜµÍ≥Ñ ÌôïÏù∏
  const { data: stats, error } = await supabase
    .from('customers')
    .select('customer_id, is_deleted, face_embedding');

  if (error) throw error;

  const activeCustomers = stats.filter(c => !c.is_deleted);
  const withFaceData = stats.filter(c => c.face_embedding !== null);

  console.log(`üìä Îç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ:`);
  console.log(`- Ï¥ù Í≥†Í∞ù: ${stats.length}Í∞ú`);
  console.log(`- ÌôúÏÑ± Í≥†Í∞ù: ${activeCustomers.length}Í∞ú`);
  console.log(`- ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞ Î≥¥Ïú†: ${withFaceData.length}Í∞ú`);

  // Ï§ëÎ≥µ Í≥†Í∞ù ID Í≤ÄÏÇ¨
  const customerIds = stats.map(c => c.customer_id);
  const uniqueIds = new Set(customerIds);
  
  if (customerIds.length !== uniqueIds.size) {
    throw new Error('Ï§ëÎ≥µÎêú Í≥†Í∞ù IDÍ∞Ä Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§.');
  }

  console.log('‚úÖ Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨ ÌÜµÍ≥º');
}

async function testAPIEndpoints(): Promise<void> {
  console.log('üîó API ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌÖåÏä§Ìä∏...');

  const baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';

  // GET /api/customer-v2 ÌÖåÏä§Ìä∏
  const getResponse = await fetch(`${baseUrl}/api/customer-v2?limit=5`);
  if (!getResponse.ok) {
    throw new Error(`GET API ÌÖåÏä§Ìä∏ Ïã§Ìå®: ${getResponse.status}`);
  }

  const getData = await getResponse.json();
  if (!getData.success || !Array.isArray(getData.customers)) {
    throw new Error('GET API ÏùëÎãµ ÌòïÏãù Ïò§Î•ò');
  }

  console.log(`‚úÖ GET API ÌÖåÏä§Ìä∏ ÌÜµÍ≥º: ${getData.customers.length}Í∞ú Ï°∞Ìöå`);
}

async function testFaceRecognition(): Promise<void> {
  console.log('üé≠ ÏñºÍµ¥ Ïù∏Ïãù Í∏∞Îä• ÌÖåÏä§Ìä∏...');

  // ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≥†Í∞ù ÌôïÏù∏
  const { data: customersWithFaces, error } = await supabase
    .from('customers')
    .select('customer_id, face_embedding')
    .not('face_embedding', 'is', null)
    .limit(1);

  if (error) throw error;

  if (customersWithFaces.length === 0) {
    console.log('‚ÑπÔ∏è ÏñºÍµ¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≥†Í∞ùÏù¥ ÏóÜÏñ¥ Í∏∞Îä• ÌÖåÏä§Ìä∏Î•º Í±¥ÎÑàÎúÅÎãàÎã§.');
    return;
  }

  // Ïú†ÏÇ¨ÎèÑ Í≤ÄÏÉâ ÌÖåÏä§Ìä∏
  const testCustomer = customersWithFaces[0];
  const { data: similarCustomers, error: searchError } = await supabase
    .rpc('find_similar_faces', {
      target_embedding: testCustomer.face_embedding.embedding,
      similarity_threshold: 0.5,
      max_results: 3
    });

  if (searchError) throw searchError;

  console.log(`‚úÖ ÏñºÍµ¥ Ïù∏Ïãù ÌÖåÏä§Ìä∏ ÌÜµÍ≥º: ${similarCustomers.length}Í∞ú Ïú†ÏÇ¨ Í≥†Í∞ù Î∞úÍ≤¨`);
}

async function testPerformance(): Promise<void> {
  console.log('‚ö° ÏÑ±Îä• ÌÖåÏä§Ìä∏...');

  const startTime = Date.now();

  // ÎåÄÎüâ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÌÖåÏä§Ìä∏
  const { data, error } = await supabase
    .rpc('search_customers', {
      search_term: null,
      include_deleted: false,
      page_size: 100,
      page_offset: 0
    });

  const endTime = Date.now();
  const duration = endTime - startTime;

  if (error) throw error;

  console.log(`üìä 100Í∞ú Í≥†Í∞ù Í≤ÄÏÉâ ÏãúÍ∞Ñ: ${duration}ms`);

  if (duration > 3000) {
    console.warn('‚ö†Ô∏è ÏÑ±Îä• Í≤ΩÍ≥†: Í≤ÄÏÉâ ÏãúÍ∞ÑÏù¥ 3Ï¥àÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§.');
  } else {
    console.log('‚úÖ ÏÑ±Îä• ÌÖåÏä§Ìä∏ ÌÜµÍ≥º');
  }
}

// Ïã§Ìñâ
if (require.main === module) {
  testCustomerMigration()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}
```

### 5.2 Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏

```bash
#!/bin/bash
# scripts/deploy-customer-migration.sh

echo "üë• Í≥†Í∞ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î∞∞Ìè¨ ÏãúÏûë..."

# 1. ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏
if [ -z "$NEXT_PUBLIC_SUPABASE_URL" ]; then
  echo "‚ùå NEXT_PUBLIC_SUPABASE_URLÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
  exit 1
fi

echo "‚úÖ ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏ ÏôÑÎ£å"

# 2. ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò
echo "üì¶ ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò Ï§ë..."
npm install

# 3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï†ÅÏö©
echo "üìä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï†ÅÏö© Ï§ë..."
npm run setup:customer-schema

# 4. Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï
echo "üóÇÔ∏è Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï Ï§ë..."
npm run setup:customer-storage

# 5. Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
echo "üì¶ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏãúÏûë..."

echo "üì• Notion Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ï§ë..."
npm run extract:notion-customers

echo "üìä Supabase Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ï§ë..."
npm run insert:customer-data

# 6. ÌÖåÏä§Ìä∏ Ïã§Ìñâ
echo "üß™ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ï§ë..."
npm run test:customer-migration

# 7. ÏôÑÎ£å ÏïàÎÇ¥
echo "‚ö†Ô∏è ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å. Îã§Ïùå Îã®Í≥ÑÎ•º ÏàòÎèôÏúºÎ°ú ÌôïÏù∏ÌïòÏÑ∏Ïöî:"
echo "1. ÌÖåÏä§Ìä∏ Í≤∞Í≥º Í≤ÄÌÜ†"
echo "2. USE_SUPABASE_CUSTOMER=true ÏÑ§Ï†ï"
echo "3. Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïû¨ÏãúÏûë"
echo "4. ÏÇ¨Ïö©Ïûê ÌÖåÏä§Ìä∏ ÏàòÌñâ"

echo "üéâ Í≥†Í∞ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î∞∞Ìè¨ ÏôÑÎ£å!"
```

### 5.3 package.json Ïä§ÌÅ¨Î¶ΩÌä∏ Ï∂îÍ∞Ä

```json
{
  "scripts": {
    "setup:customer-schema": "tsx scripts/apply-customer-schema.ts",
    "setup:customer-storage": "tsx scripts/setup-customer-storage.ts",
    "extract:notion-customers": "tsx scripts/extract-notion-customers.ts",
    "insert:customer-data": "tsx scripts/insert-customer-data.ts",
    "test:customer-migration": "tsx scripts/test-customer-migration.ts",
    "customer-migration:full": "npm run setup:customer-schema && npm run setup:customer-storage && npm run extract:notion-customers && npm run insert:customer-data && npm run test:customer-migration"
  }
}
```

## üõ†Ô∏è Ìä∏Îü¨Î∏îÏäàÌåÖ

### ÏùºÎ∞òÏ†ÅÏù∏ Î¨∏Ï†ú Î∞è Ìï¥Í≤∞Î∞©Î≤ï

#### 1. Í≥†Í∞ù ID ÏÉùÏÑ± Ìï®Ïàò Ïò§Î•ò
```bash
‚ùå Error: function generate_next_customer_id() does not exist
```
**Ìï¥Í≤∞Î∞©Î≤ï**: 
```bash
npm run setup:customer-schema
```

#### 2. Ïä§ÌÜ†Î¶¨ÏßÄ Î≤ÑÌÇ∑ Ï†ëÍ∑º Ïò§Î•ò
```bash
‚ùå Error: Bucket 'customer-profiles' not found
```
**Ìï¥Í≤∞Î∞©Î≤ï**:
```bash
npm run setup:customer-storage
```

#### 3. ÏñºÍµ¥ ÏûÑÎ≤†Îî© ÌååÏã± Ïã§Ìå®
```bash
‚ùå JSON ÌååÏã± Ïò§Î•ò: Unexpected token
```
**Ìï¥Í≤∞Î∞©Î≤ï**: ÏÜêÏÉÅÎêú Îç∞Ïù¥ÌÑ∞ Í±¥ÎÑàÎõ∞Í∏∞
```typescript
try {
  faceEmbedding = JSON.parse(embeddingString);
} catch (error) {
  console.warn('ÏñºÍµ¥ ÏûÑÎ≤†Îî© ÌååÏã± Ïã§Ìå®, Í±¥ÎÑàÎõ∞Í∏∞');
  faceEmbedding = null;
}
```

#### 4. Ï§ëÎ≥µ Í≥†Í∞ù ID Ïò§Î•ò
```bash
‚ùå Error: duplicate key value violates unique constraint
```
**Ìï¥Í≤∞Î∞©Î≤ï**: Ï§ëÎ≥µ Îç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ ÌõÑ Ïû¨ÏãúÎèÑ
```sql
DELETE FROM customers 
WHERE id NOT IN (
  SELECT MIN(id) 
  FROM customers 
  GROUP BY customer_id
);
```

### ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ëÎã® Ïãú Î≥µÍµ¨ Ï†àÏ∞®

1. **Ï¶âÏãú Î°§Î∞±**:
```bash
# ÌôòÍ≤Ω Î≥ÄÏàò Î≥µÏõê
USE_SUPABASE_CUSTOMER=false

# Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïû¨ÏãúÏûë
npm run dev
```

2. **Îç∞Ïù¥ÌÑ∞ Î≥µÍµ¨** (ÌïÑÏöîÏãú):
```sql
-- ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î°úÍ∑∏ ÌôïÏù∏
SELECT * FROM customer_migration_log 
WHERE migration_status = 'failed';

-- Ïã§Ìå®Ìïú Îç∞Ïù¥ÌÑ∞ Ïû¨Ï≤òÎ¶¨
UPDATE customer_migration_log 
SET migration_status = 'pending' 
WHERE migration_status = 'failed';
```

---

**Íµ¨ÌòÑ ÏôÑÎ£å Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏**:
- [ ] Phase 1: Ïù∏ÌîÑÎùº Ï§ÄÎπÑ ÏôÑÎ£å
- [ ] Phase 2: Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å
- [ ] Phase 3: API Í∞úÎ∞ú ÏôÑÎ£å
- [ ] Phase 4: ÏñºÍµ¥ Ïù∏Ïãù ÏãúÏä§ÌÖú ÏôÑÎ£å
- [ ] Phase 5: ÌÜµÌï© ÌÖåÏä§Ìä∏ ÏôÑÎ£å
- [ ] ÏÇ¨Ïö©Ïûê ÍµêÏú° Î∞è Î¨∏ÏÑú ÏóÖÎç∞Ïù¥Ìä∏

**ÏòàÏÉÅ ÏôÑÎ£å ÏãúÍ∞Ñ**: 5Ïùº (Í∞Å PhaseÎãπ 1Ïùº)  
**ÏúÑÌóòÎèÑ**: ÎÇÆÏùå (Í∏∞Ï°¥ ÏãúÏä§ÌÖúÍ≥º Î≥ëÎ†¨ Ïö¥ÏòÅ)  
**ÏÑ±Í≥µ Í∏∞Ï§Ä**: Í∏∞Ï°¥ Í∏∞Îä• 100% Ìò∏Ìôò + ÏÑ±Îä• Ìñ•ÏÉÅ

**Î¨∏ÏÑú Í¥ÄÎ¶¨**: Ïù¥ Íµ¨ÌòÑ Í∞ÄÏù¥ÎìúÎäî Ïã§Ï†ú Íµ¨ÌòÑ Í≥ºÏ†ïÏóêÏÑú Î∞úÏÉùÌïòÎäî Ïù¥ÏäàÏôÄ Ìï¥Í≤∞Ï±ÖÏúºÎ°ú ÏßÄÏÜç ÏóÖÎç∞Ïù¥Ìä∏Îê©ÎãàÎã§.
